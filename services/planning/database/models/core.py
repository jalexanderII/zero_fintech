# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: core/accounts.proto, core/transactions.proto, core/users.proto, core/core.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from . import common
from . import planning


@dataclass
class Account(betterproto.Message):
    """
    Account balances we be calculated using the “average daily balance
    (including new Purchases)" method.
    """

    # DB unique id
    account_id: str = betterproto.string_field(1)
    # User id this account is associated with
    user_id: str = betterproto.string_field(2)
    # The name of the account, either assigned by the user or by the financial
    # institution itself
    name: str = betterproto.string_field(3)
    # The official name of the account as given by the financial institution
    official_name: str = betterproto.string_field(4)
    type: str = betterproto.string_field(5)
    subtype: str = betterproto.string_field(6)
    # The amount of funds available to be withdrawn from the account, as
    # determined by the financial institution. For `credit`-type accounts, the
    # `available` balance typically equals the `limit` less the `current`
    # balance, less any pending outflows plus any pending inflows.
    available_balance: float = betterproto.double_field(7)
    # The total amount of funds in or owed by the account.  For `credit`-type
    # accounts, a positive balance indicates the amount owed; a negative amount
    # indicates the lender owing the account holder.
    current_balance: float = betterproto.double_field(8)
    # For `credit`-type accounts, this represents the credit limit.
    credit_limit: float = betterproto.double_field(9)
    # The ISO-4217 currency code of the balance. Always null if
    # `unofficial_currency_code` is non-null.
    iso_currency_code: str = betterproto.string_field(10)
    # The various interest rates that apply to the account.
    annual_percentage_rate: List["AnnualPercentageRates"] = betterproto.message_field(
        12
    )
    # true if a payment is currently overdue.
    is_overdue: bool = betterproto.bool_field(13)
    # The amount of the last payment.
    last_payment_amount: float = betterproto.double_field(14)
    # The date of the last statement. Dates are returned in an [ISO
    # 8601](https://wikipedia.org/wiki/ISO_8601) format (YYYY-MM-DD).
    last_statement_issue_date: str = betterproto.string_field(16)
    # The total amount owed as of the last statement issued
    last_statement_balance: float = betterproto.double_field(17)
    # The minimum payment due for the next billing cycle.
    minimum_payment_amount: float = betterproto.double_field(18)
    # The due date for the next payment. The due date is `null` if a payment is
    # not expected. Dates are returned in an [ISO
    # 8601](https://wikipedia.org/wiki/ISO_8601) format (YYYY-MM-DD).
    next_payment_due_date: str = betterproto.string_field(19)
    # Plaid’s unique identifier for the account. This value will not change
    # unless Plaid can't reconcile the account with the data returned by the
    # financial institution. This may occur, for example, when the name of the
    # account changes. If this happens a new `account_id` will be assigned to the
    # account.  The `account_id` can also change if the `access_token` is deleted
    # and the same credentials that were used to generate that `access_token` are
    # used to generate a new `access_token` on a later date. In that case, the
    # new `account_id` will be different from the old `account_id`.  If an
    # account with a specific `account_id` disappears instead of changing, the
    # account is likely closed. Closed accounts are not returned by the Plaid
    # API.  Like all Plaid identifiers, the `account_id` is case sensitive.
    plaid_account_id: str = betterproto.string_field(20)


@dataclass
class AnnualPercentageRates(betterproto.Message):
    apr_percentage: float = betterproto.double_field(1)
    apr_type: str = betterproto.string_field(2)
    balance_subject_to_apr: float = betterproto.double_field(3)
    interest_charge_amount: float = betterproto.double_field(4)


@dataclass
class CreateAccountRequest(betterproto.Message):
    """CRUD Methods"""

    account: "Account" = betterproto.message_field(1)


@dataclass
class GetAccountRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class ListAccountRequest(betterproto.Message):
    pass


@dataclass
class ListUserAccountsRequest(betterproto.Message):
    user_id: str = betterproto.string_field(1)


@dataclass
class ListAccountResponse(betterproto.Message):
    accounts: List["Account"] = betterproto.message_field(1)


@dataclass
class Transaction(betterproto.Message):
    """Transaction A representation of a transaction"""

    user_id: str = betterproto.string_field(1)
    transaction_type: str = betterproto.string_field(2)
    # The ID of a posted transaction's associated pending transaction, where
    # applicable.
    pending_transaction_id: str = betterproto.string_field(3)
    # The ID of the category to which this transaction belongs. See
    # [Categories](https://plaid.com/docs/#category-overview).
    category_id: str = betterproto.string_field(4)
    # A hierarchical array of the categories to which this transaction belongs.
    # See [Categories](https://plaid.com/docs/#category-overview).
    category: List[str] = betterproto.string_field(5)
    transaction_details: "TransactionDetails" = betterproto.message_field(6)
    # The merchant name or transaction description.
    name: str = betterproto.string_field(7)
    # The string returned by the financial institution to describe the
    # transaction.
    original_description: str = betterproto.string_field(8)
    # DB account id
    account_id: str = betterproto.string_field(9)
    # The settled value of the transaction, denominated in the account's
    # currency, as stated in `iso_currency_code`. Positive values when money
    # moves out of the account; negative values when money moves in. For example,
    # debit card purchases are positive; credit card payments, direct deposits,
    # and refunds are negative.
    amount: float = betterproto.double_field(10)
    # The ISO-4217 currency code of the transaction.
    iso_currency_code: str = betterproto.string_field(11)
    # For pending transactions, the date that the transaction occurred; for
    # posted transactions, the date that the transaction posted. Both dates are
    # returned in an [ISO 8601](https://wikipedia.org/wiki/ISO_8601) format (
    # `YYYY-MM-DD` ).
    date: str = betterproto.string_field(12)
    # When `true`, identifies the transaction as pending or unsettled. Pending
    # transaction details (name, type, amount, category ID) may change before
    # they are settled.
    pending: bool = betterproto.bool_field(13)
    # DB specific id
    transaction_id: str = betterproto.string_field(14)
    # The merchant name, as extracted by Plaid from the `name` field.
    merchant_name: str = betterproto.string_field(15)
    # The channel used to make a payment. `online:` transactions that took place
    # online. `in store:` transactions that were made at a physical location.
    # `other:` transactions that relate to banks, e.g. fees or deposits.
    payment_channel: str = betterproto.string_field(16)
    # The date that the transaction was authorized. Dates are returned in an [ISO
    # 8601](https://wikipedia.org/wiki/ISO_8601) format ( `YYYY-MM-DD` ).
    authorized_date: str = betterproto.string_field(17)
    # A high level category that communicates the broad category of the
    # transaction.
    primary_category: str = betterproto.string_field(18)
    # Provides additional granularity to the primary categorization.
    detailed_category: str = betterproto.string_field(19)
    # The ID of the account in which this transaction occurred.
    plaid_account_id: str = betterproto.string_field(20)
    # The case sensitive unique ID of the transaction.
    plaid_transaction_id: str = betterproto.string_field(21)


@dataclass
class TransactionDetails(betterproto.Message):
    """
    PaymentMeta Transaction information specific to inter-bank transfers. If
    the transaction was not an inter-bank transfer, all fields will be `null`.
    If the `transactions` object was returned by a Transactions endpoint such
    as `/transactions/get`, the `payment_meta` key will always appear, but no
    data elements are guaranteed. If the `transactions` object was returned by
    an Assets endpoint such as `/asset_report/get/` or `/asset_report/pdf/get`,
    this field will only appear in an Asset Report with Insights.
    """

    # The street address where the transaction occurred.
    address: str = betterproto.string_field(1)
    # The city where the transaction occurred.
    city: str = betterproto.string_field(2)
    # The region or state where the transaction occurred. In API versions
    # 2018-05-22 and earlier, this field is called `state`.
    state: str = betterproto.string_field(3)
    # The postal code where the transaction occurred. In API versions 2018-05-22
    # and earlier, this field is called `zip`.
    zipcode: str = betterproto.string_field(4)
    # The ISO 3166-1 alpha-2 country code where the transaction occurred.
    country: str = betterproto.string_field(5)
    # The merchant defined store number where the transaction occurred.
    store_number: str = betterproto.string_field(6)
    # The transaction reference number supplied by the financial institution.
    reference_number: str = betterproto.string_field(7)


@dataclass
class CreateTransactionRequest(betterproto.Message):
    """CRUD Methods"""

    transaction: "Transaction" = betterproto.message_field(1)


@dataclass
class GetTransactionRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class ListTransactionRequest(betterproto.Message):
    pass


@dataclass
class ListUserTransactionsRequest(betterproto.Message):
    user_id: str = betterproto.string_field(1)


@dataclass
class ListTransactionResponse(betterproto.Message):
    transactions: List["Transaction"] = betterproto.message_field(1)


@dataclass
class User(betterproto.Message):
    id: str = betterproto.string_field(1)
    username: str = betterproto.string_field(2)
    email: str = betterproto.string_field(3)
    password: str = betterproto.string_field(4)
    phone_number: str = betterproto.string_field(5)


@dataclass
class GetUserRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    username: str = betterproto.string_field(2)


@dataclass
class UpdateUserRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    user: "User" = betterproto.message_field(2)


@dataclass
class DeleteUserRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class ListUserRequest(betterproto.Message):
    pass


@dataclass
class ListUserResponse(betterproto.Message):
    users: List["User"] = betterproto.message_field(1)


@dataclass
class DeleteUserResponse(betterproto.Message):
    status: common.DELETE_STATUS = betterproto.enum_field(1)
    user: "User" = betterproto.message_field(2)


@dataclass
class GetPaymentPlanRequest(betterproto.Message):
    account_info: List["AccountInfo"] = betterproto.message_field(1)
    user_id: str = betterproto.string_field(2)
    meta_data: common.MetaData = betterproto.message_field(3)
    # indicates whether to save PaymentPlan in database
    save_plan: bool = betterproto.bool_field(4)


@dataclass
class AccountInfo(betterproto.Message):
    transaction_ids: List[str] = betterproto.string_field(1)
    account_id: str = betterproto.string_field(2)
    amount: float = betterproto.double_field(3)


@dataclass
class GetAccountDetailsResponse(betterproto.Message):
    account_details_response: "AccountDetailsResponse" = betterproto.message_field(1)


@dataclass
class AccountDetailsResponse(betterproto.Message):
    accounts: List["Account"] = betterproto.message_field(1)
    transactions: List["Transaction"] = betterproto.message_field(2)


class CoreStub(betterproto.ServiceStub):
    async def get_payment_plan(
        self,
        *,
        account_info: List["AccountInfo"] = [],
        user_id: str = "",
        meta_data: Optional[common.MetaData] = None,
        save_plan: bool = False,
    ) -> common.PaymentPlanResponse:
        """
        GetPaymentPlan makes request to the Planning service by passing it a
        list of PaymentTasks and expects to receive a list of PaymentPlans
        """

        request = GetPaymentPlanRequest()
        if account_info is not None:
            request.account_info = account_info
        request.user_id = user_id
        if meta_data is not None:
            request.meta_data = meta_data
        request.save_plan = save_plan

        return await self._unary_unary(
            "/core.Core/GetPaymentPlan",
            request,
            common.PaymentPlanResponse,
        )

    async def get_waterfall_overview(self) -> planning.WaterfallOverviewResponse:
        """
        GetWaterfallOverview accepts a request from Core service with a user ID
        to create a waterfall overview for the coming 12 month
        """

        request = planning.GetUserOverviewRequest()

        return await self._unary_unary(
            "/core.Core/GetWaterfallOverview",
            request,
            planning.WaterfallOverviewResponse,
        )

    async def get_amount_paid_percentage(
        self,
    ) -> planning.GetAmountPaidPercentageResponse:
        """
        Get the percentage of amount which has been paid of all active
        PaymentPlans for a given user ID
        """

        request = planning.GetUserOverviewRequest()

        return await self._unary_unary(
            "/core.Core/GetAmountPaidPercentage",
            request,
            planning.GetAmountPaidPercentageResponse,
        )

    async def get_percentage_covered_by_plans(
        self,
    ) -> planning.GetPercentageCoveredByPlansResponse:
        """
        Get the percentage of current balance which is covered by active plans
        for a given user ID
        """

        request = planning.GetUserOverviewRequest()

        return await self._unary_unary(
            "/core.Core/GetPercentageCoveredByPlans",
            request,
            planning.GetPercentageCoveredByPlansResponse,
        )

    async def list_user_payment_plans(self) -> common.ListPaymentPlanResponse:
        request = common.ListUserPaymentPlansRequest()

        return await self._unary_unary(
            "/core.Core/ListUserPaymentPlans",
            request,
            common.ListPaymentPlanResponse,
        )

    async def create_account(self, *, account: Optional["Account"] = None) -> Account:
        """CRUD METHODS Account"""

        request = CreateAccountRequest()
        if account is not None:
            request.account = account

        return await self._unary_unary(
            "/core.Core/CreateAccount",
            request,
            Account,
        )

    async def get_account(self, *, id: str = "") -> Account:
        request = GetAccountRequest()
        request.id = id

        return await self._unary_unary(
            "/core.Core/GetAccount",
            request,
            Account,
        )

    async def list_accounts(self) -> ListAccountResponse:
        request = ListAccountRequest()

        return await self._unary_unary(
            "/core.Core/ListAccounts",
            request,
            ListAccountResponse,
        )

    async def list_user_accounts(self, *, user_id: str = "") -> ListAccountResponse:
        request = ListUserAccountsRequest()
        request.user_id = user_id

        return await self._unary_unary(
            "/core.Core/ListUserAccounts",
            request,
            ListAccountResponse,
        )

    async def create_transaction(
        self, *, transaction: Optional["Transaction"] = None
    ) -> Transaction:
        """Transaction"""

        request = CreateTransactionRequest()
        if transaction is not None:
            request.transaction = transaction

        return await self._unary_unary(
            "/core.Core/CreateTransaction",
            request,
            Transaction,
        )

    async def get_transaction(self, *, id: str = "") -> Transaction:
        request = GetTransactionRequest()
        request.id = id

        return await self._unary_unary(
            "/core.Core/GetTransaction",
            request,
            Transaction,
        )

    async def list_transactions(self) -> ListTransactionResponse:
        request = ListTransactionRequest()

        return await self._unary_unary(
            "/core.Core/ListTransactions",
            request,
            ListTransactionResponse,
        )

    async def list_user_transactions(
        self, *, user_id: str = ""
    ) -> ListTransactionResponse:
        request = ListUserTransactionsRequest()
        request.user_id = user_id

        return await self._unary_unary(
            "/core.Core/ListUserTransactions",
            request,
            ListTransactionResponse,
        )

    async def create_payment_task(self) -> common.PaymentTask:
        """Payment Task"""

        request = common.CreatePaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/CreatePaymentTask",
            request,
            common.PaymentTask,
        )

    async def create_many_payment_task(self) -> common.CreateManyPaymentTaskResponse:
        request = common.CreateManyPaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/CreateManyPaymentTask",
            request,
            common.CreateManyPaymentTaskResponse,
        )

    async def get_payment_task(self) -> common.PaymentTask:
        request = common.GetPaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/GetPaymentTask",
            request,
            common.PaymentTask,
        )

    async def list_payment_tasks(self) -> common.ListPaymentTaskResponse:
        request = common.ListPaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/ListPaymentTasks",
            request,
            common.ListPaymentTaskResponse,
        )

    async def update_payment_task(self) -> common.PaymentTask:
        request = common.UpdatePaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/UpdatePaymentTask",
            request,
            common.PaymentTask,
        )

    async def delete_payment_task(self) -> common.DeletePaymentTaskResponse:
        request = common.DeletePaymentTaskRequest()

        return await self._unary_unary(
            "/core.Core/DeletePaymentTask",
            request,
            common.DeletePaymentTaskResponse,
        )

    async def get_user(self, *, id: str = "", username: str = "") -> User:
        """Users"""

        request = GetUserRequest()
        request.id = id
        request.username = username

        return await self._unary_unary(
            "/core.Core/GetUser",
            request,
            User,
        )

    async def list_users(self) -> ListUserResponse:
        request = ListUserRequest()

        return await self._unary_unary(
            "/core.Core/ListUsers",
            request,
            ListUserResponse,
        )

    async def update_user(self, *, id: str = "", user: Optional["User"] = None) -> User:
        request = UpdateUserRequest()
        request.id = id
        if user is not None:
            request.user = user

        return await self._unary_unary(
            "/core.Core/UpdateUser",
            request,
            User,
        )

    async def delete_user(self, *, id: str = "") -> DeleteUserResponse:
        request = DeleteUserRequest()
        request.id = id

        return await self._unary_unary(
            "/core.Core/DeleteUser",
            request,
            DeleteUserResponse,
        )
